<?php

namespace WPML\Collect\Support\Traits {
    trait Macroable
    {
        /**
         * The registered string macros.
         *
         * @var callable[]
         */
        protected static $macros = [];
        /**
         * Register a custom macro.
         *
         * @param  string    $name
         * @param  callable  $macro
         * @return void
         */
        public static function macro($name, callable $macro)
        {
        }
        /**
         * Checks if macro is registered.
         *
         * @param  string  $name
         * @return bool
         */
        public static function hasMacro($name)
        {
        }
        /**
         * Dynamically handle calls to the class.
         *
         * @param  string  $method
         * @param  mixed[]   $parameters
         * @return mixed
         *
         * @throws \BadMethodCallException
         */
        public static function __callStatic($method, $parameters)
        {
        }
        /**
         * Dynamically handle calls to the class.
         *
         * @param  string  $method
         * @param  mixed[]   $parameters
         * @return mixed
         *
         * @throws \BadMethodCallException
         */
        public function __call($method, $parameters)
        {
        }
    }
}
namespace WPML\Collect\Support {
    class Arr
    {
        use \WPML\Collect\Support\Traits\Macroable;
        /**
         * Determine whether the given value is array accessible.
         *
         * @param  mixed  $value
         * @return bool
         */
        public static function accessible($value)
        {
        }
        /**
         * Add an element to an array using "dot" notation if it doesn't exist.
         *
         * @param  mixed[]   $array
         * @param  string  $key
         * @param  mixed   $value
         * @return mixed[]
         */
        public static function add($array, $key, $value)
        {
        }
        /**
         * Collapse an array of arrays into a single array.
         *
         * @param  mixed[]  $array
         * @return mixed[]
         */
        public static function collapse($array)
        {
        }
        /**
         * Divide an array into two arrays. One with keys and the other with values.
         *
         * @param  mixed[]  $array
         * @return mixed[]
         */
        public static function divide($array)
        {
        }
        /**
         * Flatten a multi-dimensional associative array with dots.
         *
         * @param  mixed[]   $array
         * @param  string  $prepend
         * @return mixed[]
         */
        public static function dot($array, $prepend = '')
        {
        }
        /**
         * Get all of the given array except for a specified array of items.
         *
         * @param  mixed[]  $array
         * @param  mixed[]|string  $keys
         * @return mixed[]
         */
        public static function except($array, $keys)
        {
        }
        /**
         * Determine if the given key exists in the provided array.
         *
         * @param  \ArrayAccess<mixed>|mixed[]  $array
         * @param  string|int  $key
         * @return bool
         */
        public static function exists($array, $key)
        {
        }
        /**
         * Return the first element in an array passing a given truth test.
         *
         * @param  mixed[]  $array
         * @param  callable|null  $callback
         * @param  mixed  $default
         * @return mixed
         */
        public static function first($array, callable $callback = null, $default = null)
        {
        }
        /**
         * Return the last element in an array passing a given truth test.
         *
         * @param  mixed[]  $array
         * @param  callable|null  $callback
         * @param  mixed  $default
         * @return mixed
         */
        public static function last($array, callable $callback = null, $default = null)
        {
        }
        /**
         * Flatten a multi-dimensional array into a single level.
         *
         * @param  mixed[]  $array
         * @param  int  $depth
         * @return array
         */
        public static function flatten($array, $depth = INF)
        {
        }
        /**
         * Remove one or many array items from a given array using "dot" notation.
         *
         * @param  mixed[]  $array
         * @param  mixed[]|string  $keys
         * @return void
         */
        public static function forget(&$array, $keys)
        {
        }
        /**
         * Get an item from an array using "dot" notation.
         *
         * @param  \ArrayAccess<mixed>|mixed[]  $array
         * @param  string  $key
         * @param  mixed   $default
         * @return mixed
         */
        public static function get($array, $key, $default = null)
        {
        }
        /**
         * Check if an item or items exist in an array using "dot" notation.
         *
         * @param  \ArrayAccess<mixed>|mixed[]  $array
         * @param  string|mixed[]  $keys
         * @return bool
         */
        public static function has($array, $keys)
        {
        }
        /**
         * Determines if an array is associative.
         *
         * An array is "associative" if it doesn't have sequential numerical keys beginning with zero.
         *
         * @param  mixed[]  $array
         * @return bool
         */
        public static function isAssoc(array $array)
        {
        }
        /**
         * Get a subset of the items from the given array.
         *
         * @param  mixed[]  $array
         * @param  mixed[]|string  $keys
         * @return array
         */
        public static function only($array, $keys)
        {
        }
        /**
         * Pluck an array of values from an array.
         *
         * @param  mixed[]  $array
         * @param  string|mixed[]  $value
         * @param  string|mixed[]|null  $key
         * @return mixed[]
         */
        public static function pluck($array, $value, $key = null)
        {
        }
        /**
         * Explode the "value" and "key" arguments passed to "pluck".
         *
         * @param  string|mixed[]  $value
         * @param  string|mixed[]|null  $key
         * @return mixed[]
         */
        protected static function explodePluckParameters($value, $key)
        {
        }
        /**
         * Push an item onto the beginning of an array.
         *
         * @param  mixed[]  $array
         * @param  mixed  $value
         * @param  mixed  $key
         * @return mixed[]
         */
        public static function prepend($array, $value, $key = null)
        {
        }
        /**
         * Get a value from the array, and remove it.
         *
         * @param  mixed[]   $array
         * @param  string  $key
         * @param  mixed   $default
         * @return mixed
         */
        public static function pull(&$array, $key, $default = null)
        {
        }
        /**
         * Set an array item to a given value using "dot" notation.
         *
         * If no key is given to the method, the entire array will be replaced.
         *
         * @param  mixed[]   $array
         * @param  string  $key
         * @param  mixed   $value
         * @return mixed[]
         */
        public static function set(&$array, $key, $value)
        {
        }
        /**
         * Sort the array using the given callback or "dot" notation.
         *
         * @param  mixed[]  $array
         * @param  callable|string  $callback
         * @return mixed[]
         */
        public static function sort($array, $callback)
        {
        }
        /**
         * Recursively sort an array by keys and values.
         *
         * @param  mixed[]  $array
         * @return mixed[]
         */
        public static function sortRecursive($array)
        {
        }
        /**
         * Filter the array using the given callback.
         *
         * @param  mixed[]  $array
         * @param  callable  $callback
         * @return mixed[]
         */
        public static function where($array, callable $callback)
        {
        }
        /**
         * @param mixed ...$arrays
         *
         * @return mixed[]|mixed[mixed]
         */
        public static function crossJoin(...$arrays)
        {
        }
    }
}
namespace WPML\Collect\Contracts\Support {
    interface Arrayable
    {
        /**
         * Get the instance as an array.
         *
         * @return array
         */
        public function toArray();
    }
    interface Jsonable
    {
        /**
         * Convert the object to its JSON representation.
         *
         * @param  int  $options
         * @return string
         */
        public function toJson($options = 0);
    }
}
namespace WPML\Collect\Support {
    class Collection implements \ArrayAccess, \WPML\Collect\Contracts\Support\Arrayable, \Countable, \IteratorAggregate, \WPML\Collect\Contracts\Support\Jsonable, \JsonSerializable
    {
        use \WPML\Collect\Support\Traits\Macroable;
        /**
         * The items contained in the collection.
         *
         * @var mixed[]
         */
        protected $items = [];
        /**
         * Create a new collection.
         *
         * @param  mixed  $items
         * @return void
         */
        public function __construct($items = [])
        {
        }
        /**
         * Create a new collection instance if the value isn't one already.
         *
         * @param  mixed[]  $items
         * @return static
         */
        public static function make($items = [])
        {
        }
        /**
         * Get all of the items in the collection.
         *
         * @return mixed[]
         */
        public function all()
        {
        }
        /**
         * Get the average value of a given key.
         *
         * @param  callable|string|null  $callback
         * @return float|void
         */
        public function avg($callback = null)
        {
        }
        /**
         * Alias for the "avg" method.
         *
         * @param  callable|string|null  $callback
         * @return float|void
         */
        public function average($callback = null)
        {
        }
        /**
         * Get the median of a given key.
         *
         * @param  null $key
         * @return float|void
         */
        public function median($key = null)
        {
        }
        /**
         * Get the mode of a given key.
         *
         * @param  null $key
         * @return mixed[]|void
         */
        public function mode($key = null)
        {
        }
        /**
         * Collapse the collection of items into a single array.
         *
         * @return static
         */
        public function collapse()
        {
        }
        /**
         * Determine if an item exists in the collection.
         *
         * @param  mixed  $key
         * @param  mixed  $value
         * @return bool
         */
        public function contains($key, $value = null)
        {
        }
        /**
         * Determine if an item exists in the collection using strict comparison.
         *
         * @param  mixed  $key
         * @param  mixed  $value
         * @return bool
         */
        public function containsStrict($key, $value = null)
        {
        }
        /**
         * Get the items in the collection that are not present in the given items.
         *
         * @param  mixed  $items
         * @return static
         */
        public function diff($items)
        {
        }
        /**
         * Get the items in the collection whose keys are not present in the given items.
         *
         * @param  mixed  $items
         * @return static
         */
        public function diffKeys($items)
        {
        }
        /**
         * Execute a callback over each item.
         *
         * @param  callable  $callback
         * @return $this
         */
        public function each(callable $callback)
        {
        }
        /**
         * Create a new collection consisting of every n-th element.
         *
         * @param  int  $step
         * @param  int  $offset
         * @return static
         */
        public function every($step, $offset = 0)
        {
        }
        /**
         * Get all items except for those with the specified keys.
         *
         * @param  mixed  $keys
         * @return static
         */
        public function except($keys)
        {
        }
        /**
         * Run a filter over each of the items.
         *
         * @param  callable|null  $callback
         * @return static
         */
        public function filter(callable $callback = null)
        {
        }
        /**
         * Filter items by the given key value pair.
         *
         * @param  string  $key
         * @param  mixed  $operator
         * @param  mixed  $value
         * @return static
         */
        public function where($key, $operator, $value = null)
        {
        }
        /**
         * Get an operator checker callback.
         *
         * @param  string  $key
         * @param  string  $operator
         * @param  mixed  $value
         * @return \Closure
         */
        protected function operatorForWhere($key, $operator, $value)
        {
        }
        /**
         * Filter items by the given key value pair using strict comparison.
         *
         * @param  string  $key
         * @param  mixed  $value
         * @return static
         */
        public function whereStrict($key, $value)
        {
        }
        /**
         * Filter items by the given key value pair.
         *
         * @param  string  $key
         * @param  mixed  $values
         * @param  bool  $strict
         * @return static
         */
        public function whereIn($key, $values, $strict = false)
        {
        }
        /**
         * Filter items by the given key value pair using strict comparison.
         *
         * @param  string  $key
         * @param  mixed  $values
         * @return static
         */
        public function whereInStrict($key, $values)
        {
        }
        /**
         * Get the first item from the collection.
         *
         * @param  callable|null  $callback
         * @param  mixed  $default
         * @return mixed
         */
        public function first(callable $callback = null, $default = null)
        {
        }
        /**
         * Get a flattened array of the items in the collection.
         *
         * @param  int  $depth
         * @return static
         */
        public function flatten($depth = INF)
        {
        }
        /**
         * Flip the items in the collection.
         *
         * @return static
         */
        public function flip()
        {
        }
        /**
         * Remove an item from the collection by key.
         *
         * @param  string|array  $keys
         * @return $this
         */
        public function forget($keys)
        {
        }
        /**
         * Get an item from the collection by key.
         *
         * @param  mixed  $key
         * @param  mixed  $default
         * @return mixed
         */
        public function get($key, $default = null)
        {
        }
        /**
         * Group an associative array by a field or using a callback.
         *
         * @param  callable|string  $groupBy
         * @param  bool  $preserveKeys
         * @return static
         */
        public function groupBy($groupBy, $preserveKeys = false)
        {
        }
        /**
         * Key an associative array by a field or using a callback.
         *
         * @param  callable|string  $keyBy
         * @return static
         */
        public function keyBy($keyBy)
        {
        }
        /**
         * Determine if an item exists in the collection by key.
         *
         * @param  mixed  $key
         * @return bool
         */
        public function has($key)
        {
        }
        /**
         * Concatenate values of a given key as a string.
         *
         * @param  string  $value
         * @param  string  $glue
         * @return string
         */
        public function implode($value, $glue = null)
        {
        }
        /**
         * Intersect the collection with the given items.
         *
         * @param  mixed  $items
         * @return static
         */
        public function intersect($items)
        {
        }
        /**
         * Determine if the collection is empty or not.
         *
         * @return bool
         */
        public function isEmpty()
        {
        }
        /**
         * Determine if the given value is callable, but not a string.
         *
         * @param  mixed  $value
         * @return bool
         */
        protected function useAsCallable($value)
        {
        }
        /**
         * Get the keys of the collection items.
         *
         * @return static
         */
        public function keys()
        {
        }
        /**
         * Get the last item from the collection.
         *
         * @param  callable|null  $callback
         * @param  mixed  $default
         * @return mixed
         */
        public function last(callable $callback = null, $default = null)
        {
        }
        /**
         * Get the values of a given key.
         *
         * @param  string  $value
         * @param  string|null  $key
         * @return static
         */
        public function pluck($value, $key = null)
        {
        }
        /**
         * Run a map over each of the items.
         *
         * @param  callable  $callback
         * @return static
         */
        public function map(callable $callback)
        {
        }
        /**
         * Run an associative map over each of the items.
         *
         * The callback should return an associative array with a single key/value pair.
         *
         * @param  callable  $callback
         * @return static
         */
        public function mapWithKeys(callable $callback)
        {
        }
        /**
         * Map a collection and flatten the result by a single level.
         *
         * @param  callable  $callback
         * @return static
         */
        public function flatMap(callable $callback)
        {
        }
        /**
         * Get the max value of a given key.
         *
         * @param  callable|string|null  $callback
         * @return mixed
         */
        public function max($callback = null)
        {
        }
        /**
         * Merge the collection with the given items.
         *
         * @param  mixed  $items
         * @return static
         */
        public function merge($items)
        {
        }
        /**
         * Create a collection by using this collection for keys and another for its values.
         *
         * @param  mixed  $values
         * @return static
         */
        public function combine($values)
        {
        }
        /**
         * Union the collection with the given items.
         *
         * @param  mixed  $items
         * @return static
         */
        public function union($items)
        {
        }
        /**
         * Get the min value of a given key.
         *
         * @param  callable|string|null  $callback
         * @return mixed
         */
        public function min($callback = null)
        {
        }
        /**
         * Get the items with the specified keys.
         *
         * @param  mixed  $keys
         * @return static
         */
        public function only($keys)
        {
        }
        /**
         * "Paginate" the collection by slicing it into a smaller collection.
         *
         * @param  int  $page
         * @param  int  $perPage
         * @return static
         */
        public function forPage($page, $perPage)
        {
        }
        /**
         * Partition the collection into two arrays using the given callback or key.
         *
         * @param  callable|string  $key
         * @param  mixed  $operator
         * @param  mixed  $value
         * @return static
         */
        public function partition($key, $operator = null, $value = null)
        {
        }
        /**
         * Pass the collection to the given callback and return the result.
         *
         * @param  callable $callback
         * @return mixed
         */
        public function pipe(callable $callback)
        {
        }
        /**
         * Get and remove the last item from the collection.
         *
         * @return mixed
         */
        public function pop()
        {
        }
        /**
         * Push an item onto the beginning of the collection.
         *
         * @param  mixed  $value
         * @param  mixed  $key
         * @return $this
         */
        public function prepend($value, $key = null)
        {
        }
        /**
         * Push an item onto the end of the collection.
         *
         * @param  mixed  $value
         * @return $this
         */
        public function push($value)
        {
        }
        /**
         * Get and remove an item from the collection.
         *
         * @param  mixed  $key
         * @param  mixed  $default
         * @return mixed
         */
        public function pull($key, $default = null)
        {
        }
        /**
         * Put an item in the collection by key.
         *
         * @param  mixed  $key
         * @param  mixed  $value
         * @return $this
         */
        public function put($key, $value)
        {
        }
        /**
         * Get one or more items randomly from the collection.
         *
         * @param  int  $amount
         * @return mixed
         *
         * @throws \InvalidArgumentException
         */
        public function random($amount = 1)
        {
        }
        /**
         * Reduce the collection to a single value.
         *
         * @param  callable  $callback
         * @param  mixed     $initial
         * @return mixed
         */
        public function reduce(callable $callback, $initial = null)
        {
        }
        /**
         * Create a collection of all elements that do not pass a given truth test.
         *
         * @param  callable|mixed  $callback
         * @return static
         */
        public function reject($callback)
        {
        }
        /**
         * Reverse items order.
         *
         * @return static
         */
        public function reverse()
        {
        }
        /**
         * Search the collection for a given value and return the corresponding key if successful.
         *
         * @param  mixed  $value
         * @param  bool   $strict
         * @return mixed
         */
        public function search($value, $strict = false)
        {
        }
        /**
         * Get and remove the first item from the collection.
         *
         * @return mixed
         */
        public function shift()
        {
        }
        /**
         * Shuffle the items in the collection.
         *
         * @param int $seed
         * @return static
         */
        public function shuffle($seed = null)
        {
        }
        /**
         * Slice the underlying collection array.
         *
         * @param  int   $offset
         * @param  int   $length
         * @return static
         */
        public function slice($offset, $length = null)
        {
        }
        /**
         * Split a collection into a certain number of groups.
         *
         * @param  int  $numberOfGroups
         * @return static
         */
        public function split($numberOfGroups)
        {
        }
        /**
         * Chunk the underlying collection array.
         *
         * @param  int   $size
         * @return static
         */
        public function chunk($size)
        {
        }
        /**
         * Sort through each item with a callback.
         *
         * @param  callable|null  $callback
         * @return static
         */
        public function sort(callable $callback = null)
        {
        }
        /**
         * Sort the collection using the given callback.
         *
         * @param  callable|string  $callback
         * @param  int   $options
         * @param  bool  $descending
         * @return static
         */
        public function sortBy($callback, $options = SORT_REGULAR, $descending = false)
        {
        }
        /**
         * Sort the collection in descending order using the given callback.
         *
         * @param  callable|string  $callback
         * @param  int  $options
         * @return static
         */
        public function sortByDesc($callback, $options = SORT_REGULAR)
        {
        }
        /**
         * Splice a portion of the underlying collection array.
         *
         * @param  int  $offset
         * @param  int|null  $length
         * @param  mixed  $replacement
         * @return static
         */
        public function splice($offset, $length = null, $replacement = [])
        {
        }
        /**
         * Get the sum of the given values.
         *
         * @param  callable|string|null  $callback
         * @return mixed
         */
        public function sum($callback = null)
        {
        }
        /**
         * Take the first or last {$limit} items.
         *
         * @param  int  $limit
         * @return static
         */
        public function take($limit)
        {
        }
        /**
         * Transform each item in the collection using a callback.
         *
         * @param  callable  $callback
         * @return $this
         */
        public function transform(callable $callback)
        {
        }
        /**
         * Return only unique items from the collection array.
         *
         * @param  string|callable|null  $key
         * @param  bool  $strict
         *
         * @return static
         */
        public function unique($key = null, $strict = false)
        {
        }
        /**
         * Return only unique items from the collection array using strict comparison.
         *
         * @param  string|callable|null  $key
         * @return static
         */
        public function uniqueStrict($key = null)
        {
        }
        /**
         * Reset the keys on the underlying array.
         *
         * @return static
         */
        public function values()
        {
        }
        /**
         * Get a value retrieving callback.
         *
         * @param  string  $value
         * @return callable
         */
        protected function valueRetriever($value)
        {
        }
        /**
         * Zip the collection together with one or more arrays.
         *
         * e.g. new Collection([1, 2, 3])->zip([4, 5, 6]);
         *      => [[1, 4], [2, 5], [3, 6]]
         *
         * @param  mixed ...$items
         * @return static
         */
        public function zip($items)
        {
        }
        /**
         * Get the collection of items as a plain array.
         *
         * @return array
         */
        public function toArray()
        {
        }
        /**
         * Convert the object into something JSON serializable.
         *
         * @return array
         */
        public function jsonSerialize()
        {
        }
        /**
         * Get the collection of items as JSON.
         *
         * @param  int  $options
         * @return string
         */
        public function toJson($options = 0)
        {
        }
        /**
         * Get an iterator for the items.
         *
         * @return \ArrayIterator
         */
        public function getIterator()
        {
        }
        /**
         * Get a CachingIterator instance.
         *
         * @param  int  $flags
         * @return \CachingIterator
         */
        public function getCachingIterator($flags = \CachingIterator::CALL_TOSTRING)
        {
        }
        /**
         * Count the number of items in the collection.
         *
         * @return int
         */
        public function count()
        {
        }
        /**
         * Get a base Support collection instance from this collection.
         *
         * @return \WPML\Collect\Support\Collection
         */
        public function toBase()
        {
        }
        /**
         * Determine if an item exists at an offset.
         *
         * @param  mixed  $key
         * @return bool
         */
        public function offsetExists($key)
        {
        }
        /**
         * Get an item at a given offset.
         *
         * @param  mixed  $key
         * @return mixed
         */
        public function offsetGet($key)
        {
        }
        /**
         * Set the item at a given offset.
         *
         * @param  mixed  $key
         * @param  mixed  $value
         * @return void
         */
        public function offsetSet($key, $value)
        {
        }
        /**
         * Unset the item at a given offset.
         *
         * @param  string  $key
         * @return void
         */
        public function offsetUnset($key)
        {
        }
        /**
         * Convert the collection to its string representation.
         *
         * @return string
         */
        public function __toString()
        {
        }
        /**
         * Results array of items from Collection or Arrayable.
         *
         * @param  mixed  $items
         * @return array
         */
        protected function getArrayableItems($items)
        {
        }
        /** Those methods exist in the latest version of the library and have been copied here */
        /**
         * Run a dictionary map over the items.
         *
         * The callback should return an associative array with a single key/value pair.
         *
         * @param  callable  $callback
         * @return $this
         */
        public function mapToDictionary(callable $callback)
        {
        }
        /**
         * Run a grouping map over the items.
         *
         * The callback should return an associative array with a single key/value pair.
         *
         * @param  callable  $callback
         * @return static
         */
        public function mapToGroups(callable $callback)
        {
        }
        /**
         * Move the items meeting the condition to the front of the collection
         *
         * @param callable $condition
         *
         * @return Collection - A new collection
         */
        public function prioritize(callable $condition)
        {
        }
        /**
         * Convert an associative array of key => value to array of pairs [ key, value ].
         *
         * @return Collection
         */
        public function assocToPair()
        {
        }
        /**
         * Convert an array of pairs [ key, value ] to an associative array of key => value.
         *
         * @return Collection
         */
        public function pairToAssoc()
        {
        }
        /**
         * Executes the given function for each item while the total execution time is less than the time out.
         * Returns the unprocessed items if a timeout occurred.
         *
         * @param callable $fn Function to all for each item.
         * @param int $timeout Timeout in seconds.
         *
         * @return Collection
         */
        public function eachWithTimeout(callable $fn, $timeout)
        {
        }
        /**
         * Determine if the collection is not empty.
         *
         * @return bool
         */
        public function isNotEmpty()
        {
        }
        /**
         * Cross join with the given lists, returning all possible permutations.
         *
         * @param  mixed  ...$lists
         * @return static
         */
        public function crossJoin(...$lists)
        {
        }
    }
}
namespace WPML\Setup {
    class Option
    {
        const POSTS_LIMIT_FOR_AUTOMATIC_TRANSLATION = 10;
        const OPTION_GROUP = 'setup';
        const CURRENT_STEP = 'current-step';
        const ORIGINAL_LANG = 'original-lang';
        const TRANSLATED_LANGS = 'translated-langs';
        const WHO_MODE = 'who-mode';
        const TRANSLATE_EVERYTHING = 'translate-everything';
        const TRANSLATE_EVERYTHING_COMPLETED = 'translate-everything-completed';
        const TM_ALLOWED = 'is-tm-allowed';
        const REVIEW_MODE = 'review-mode';
        const NO_REVIEW = 'no-review';
        const PUBLISH_AND_REVIEW = 'publish-and-review';
        const HOLD_FOR_REVIEW = 'before-publish';
        public static function getCurrentStep()
        {
        }
        public static function saveCurrentStep($step)
        {
        }
        public static function getOriginalLang()
        {
        }
        public static function setOriginalLang($lang)
        {
        }
        public static function getTranslationLangs()
        {
        }
        public static function setTranslationLangs(array $langs)
        {
        }
        public static function setOnlyMyselfAsDefault()
        {
        }
        public static function setTranslationMode(array $mode)
        {
        }
        public static function getTranslationMode()
        {
        }
        public static function setTranslateEverythingDefault()
        {
        }
        public static function shouldTranslateEverything($default = false)
        {
        }
        /** @param bool $state */
        public static function setTranslateEverything($state)
        {
        }
        public static function setTranslateEverythingCompleted($completed)
        {
        }
        public static function markPostTypeAsCompleted($postType, $languages)
        {
        }
        public static function getTranslateEverythingCompleted()
        {
        }
        public static function isTMAllowed()
        {
        }
        public static function setTMAllowed($isTMAllowed)
        {
        }
        public static function setReviewMode($mode)
        {
        }
        public static function getReviewMode()
        {
        }
        public static function shouldBeReviewed()
        {
        }
        private static function get($key, $default = null)
        {
        }
        private static function set($key, $value)
        {
        }
        public static function getTranslateEverythingDefaultInSetup()
        {
        }
    }
}
namespace WPML\Element\API {
    /**
     * @method static array getActive()
     *
     * It returns an array of the active languages.
     *
     * The returned array is indexed by language code and every element has the following structure:
     * ```
     *  'fr' => [
     *      'code'           => 'fr',
     *      'id'             => 3,
     *      'english_name'   => 'French',
     *      'native_name'    => 'Français',
     *      'major'          => 1,
     *      'default_locale' => 'fr_FR',
     *      'encode_url'     => 0,
     *      'tag'            => 'fr ,
     *      'display_name'   => 'French
     *  ]
     * ```
     * @method static array getSecondaries()
     *
     * It returns an array of the secondary languages.
     *
     * The returned array is indexed by language code and every element has the following structure:
     * ```
     *  'fr' => [
     *      'code'           => 'fr',
     *      'id'             => 3,
     *      'english_name'   => 'French',
     *      'native_name'    => 'Français',
     *      'major'          => 1,
     *      'default_locale' => 'fr_FR',
     *      'encode_url'     => 0,
     *      'tag'            => 'fr ,
     *      'display_name'   => 'French
     *  ]
     * ```
     * @method static array getSecondaryCodes()
     *
     * It returns an array of the secondary language codes.
     *
     * @method static array|callback getLanguageDetails( ...$code ) - Curried :: string->array
     *
     * It returns details of a language.
     *
     * An example output:
     * ```
     * [
     *      'code'           => 'fr',
     *      'id'             => 3,
     *      'english_name'   => 'French',
     *      'native_name'    => 'Français',
     *      'major'          => 1,
     *      'default_locale' => 'fr_FR',
     *      'encode_url'     => 0,
     *      'tag'            => 'fr ,
     *      'display_name'   => 'French
     *  ]
     * ```
     *
     *
     * @method static array getDefault()
     *
     * It returns a default language details.
     *
     * An example output:
     *```
     *[
     *      'code'           => 'fr',
     *      'id'             => 3,
     *      'english_name'   => 'French',
     *      'native_name'    => 'Français',
     *      'major'          => 1,
     *      'default_locale' => 'fr_FR',
     *      'encode_url'     => 0,
     *      'tag'            => 'fr ,
     *      'display_name'   => 'French
     * ]
     *```
     *
     * @method static array getDefaultCode()
     *
     * It returns a default language code.
     *
     * @method static callable|string getFlagUrl( ...$code ) - Curried :: string → string
     *
     * Gets the flag url for the given language code.
     *
     * @method static callable|array withFlags( ...$langs ) - Curried :: [code => lang] → [code => lang]
     *
     * Adds the language flag url to the array of languages.
     *
     * @method static array getAll( $lang = false ) string|false → [lang]
     *
     * It returns an array of the all the languages.
     *
     * The returned array is indexed by language code and every element has the following structure:
     * ```
     *  'fr' => [
     *      'code'           => 'fr',
     *      'id'             => 3,
     *      'english_name'   => 'French',
     *      'native_name'    => 'Français',
     *      'major'          => 1,
     *      'default_locale' => 'fr_FR',
     *      'encode_url'     => 0,
     *      'tag'            => 'fr ,
     *      'display_name'   => 'French
     *  ]
     * ```
     *
     * @method static callable|int|false setLanguageTranslation( ...$langCode, ...$displayLangCode, ...$name ) - Curried :: string->string->string->int|false
     *
     * It sets a language translation.
     *
     * @method static callable|int|false setFlag( ...$langCode, ...$flag, ...$fromTemplate ) - Curried :: string->string->bool->int|false
     *
     * It sets a language flag.
     *
     * @method static callable|string getWPLocale( ...$langDetails ) - Curried :: array->string
     */
    class Languages
    {
        use \WPML\Collect\Support\Traits\Macroable;
        const LANGUAGES_MAPPING_OPTION = 'wpml_languages_mapping';
        /**
         * @return void
         */
        public static function init()
        {
        }
        /**
         * Curried :: string → bool
         * Determine if the language is Right to Left
         *
         * @param string|null $code
         *
         * @return callable|bool
         */
        public static function isRtl($code = null)
        {
        }
        /**
         * Curried :: [code => lang] → [code => lang]
         *
         * Adds language direction, right to left, to the languages data
         *
         * @param string[] $langs
         *
         * @return callable|mixed[]
         */
        public static function withRtl($langs = null)
        {
        }
        /**
         * Curried :: string -> string|false
         *
         * Returns the language code given a locale
         *
         * @param string|null $locale
         *
         * @return callable|string|false
         */
        public static function localeToCode($locale = null)
        {
        }
        /**
         * @param string $code
         * @param string $english_name
         * @param string $default_locale
         * @param int    $major
         * @param int    $active
         * @param int    $encode_url
         * @param string $tag
         * @param string $country
         *
         * @return bool|int
         */
        public static function add($code, $english_name, $default_locale, $major = 0, $active = 0, $encode_url = 0, $tag = '', $country = null)
        {
        }
        /**
         * @param string $customLanguageCode
         * @param string $mappedLanguageCode
         */
        public static function addMapping($customLanguageCode, $mappedLanguageCode)
        {
        }
        /**
         * @param string $customLanguageCode
         *
         * @return string|null
         */
        public static function getMappedLanguage($customLanguageCode)
        {
        }
        /**
         * @return Just|Nothing
         */
        public static function getUserLanguageCode()
        {
        }
    }
}
namespace WPML\Records {
    class Translations
    {
        const OLDEST_FIRST = 'ASC';
        const NEWEST_FIRST = 'DESC';
        /**
         * @param \wpdb|null  $wpdb
         * @param array|null  $order
         * @param string|null $postType
         *
         * @return callable|Collection
         */
        public static function getForPostType(\wpdb $wpdb = null, array $order = null, $postType = null)
        {
        }
        /**
         * @param string|null     $defaultLang
         * @param Collection|null $translations
         *
         * @return callable|Collection
         */
        public static function getSource($defaultLang = null, \WPML\Collect\Support\Collection $translations = null)
        {
        }
    }
}
namespace WPML\Element\API {
    /**
     * Class PostTranslations
     * @package WPML\Element\API
     * @method static callable|int setAsSource( ...$el_id, ...$language_code ) - Curried :: int → string → void
     * @method static callable|int setAsTranslationOf( ...$el_id, ...$translated_id, ...$language_code )
     * @method static callable|array get( ...$el_id ) - Curried :: int → [object]
     * @method static callable|array getIfOriginal( ...$el_id ) - Curried :: int → [object]
     * @method static callable|array getOriginal( ...$element_id ) - Curried :: int → object|null
     * @method static callable|array getOriginalId( ...$element_id ) - Curried :: int → int
     * @method static callable|array getJobTranslation( ...$job ) - Curried :: \stdClass->array
     * @method static callable|int getJobTranslatedPostId( ...$job ) - Curried :: \stdClass->int
     */
    class PostTranslations
    {
        use \WPML\Collect\Support\Traits\Macroable;
        /**
         * @return void
         */
        public static function init()
        {
        }
        /**
         * @param callable $fn
         *
         * @return \Closure
         */
        public static function withPostType($fn)
        {
        }
    }
}
namespace WPML\WP {
    class OptionManager
    {
        private $group_keys_key = 'WPML_Group_Keys';
        /**
         * Get a WordPress option that is stored by group.
         *
         * @param string $group
         * @param string $key
         * @param mixed  $default
         *
         * @return mixed
         */
        public function get($group, $key, $default = false)
        {
        }
        /**
         * Save a WordPress option that is stored by group
         * The value is then stored by key in the group.
         *
         * eg. set( 'TM-wizard', 'complete', 'true' ) will create or add to the option WPML(TM-wizard)
         * The dat in the option will then be an array of items stored by key.
         *
         * @param string $group
         * @param string $key
         * @param mixed  $value
         * @param bool   $autoload
         */
        public function set($group, $key, $value, $autoload = true)
        {
        }
        /**
         * @param string $group
         *
         * @return string
         */
        private function get_key($group)
        {
        }
        /**
         * @param string $group_key
         */
        private function store_group_key($group_key)
        {
        }
        /**
         * Returns all the options that need to be deleted on WPML reset.
         *
         * @param array $options
         *
         * @return array
         */
        public function reset_options($options)
        {
        }
        /**
         * Curried :: string → string → a → void
         * @param string|null $group
         * @param string|null $key
         * @param mixed|null $value
         *
         * @return callable|void
         */
        public static function updateWithoutAutoLoad($group = null, $key = null, $value = null)
        {
        }
        /**
         * Curried :: string → string → a → void
         * @param string|null $group
         * @param string|null $key
         * @param mixed|null $value
         *
         * @return callable|void
         */
        public static function update($group = null, $key = null, $value = null)
        {
        }
        /**
         * Curried :: a → string → string → b
         * @param mixed|null $default
         * @param string|null $group
         * @param string|null $key
         *
         * @return callable|mixed
         */
        public static function getOr($default = null, $group = null, $key = null)
        {
        }
    }
}
namespace WPML\FP {
    trait Curryable
    {
        /**
         * The registered string curried methods.
         *
         * @var string[]
         */
        protected static $curried = [];
        /**
         * Register a custom curried function.
         *
         * @param string   $name
         * @param int      $argCount
         * @param callable $fn
         *
         * @return void
         */
        public static function curryN($name, $argCount, callable $fn)
        {
        }
        /**
         * Checks if curried function is registered.
         *
         * @param string $name
         *
         * @return bool
         */
        public static function hasCurry($name)
        {
        }
        /**
         * Dynamically handle calls to the class.
         *
         * @param string  $method
         * @param mixed[] $parameters
         *
         * @return mixed
         *
         * @throws \BadMethodCallException
         */
        public static function __callStatic($method, $parameters)
        {
        }
        /**
         * Dynamically handle calls to the class.
         *
         * @param string  $method
         * @param mixed[] $parameters
         *
         * @return mixed
         *
         * @throws \BadMethodCallException
         */
        public function __call($method, $parameters)
        {
        }
        /**
         * @param int     $count
         * @param \Closure $fn
         *
         * @return \Closure
         */
        private function curryItCall($count, \Closure $fn)
        {
        }
        /**
         * @param int     $count
         * @param \Closure $fn
         *
         * @return \Closure
         */
        private static function curryItStaticCall($count, \Closure $fn)
        {
        }
    }
}
namespace WPML\Element\API {
    /**
     * Class Post
     * @package WPML\Element\API
     *
     * @method static callable|string getLang( ...$postId ): Curried :: int->string
     */
    class Post
    {
        use \WPML\FP\Curryable;
        public static function init()
        {
        }
    }
}
namespace WPML {
    class DocPage
    {
        public static function getTranslateAutomatically()
        {
        }
        public static function gettingStartedGuide()
        {
        }
        public static function editorOptions()
        {
        }
    }
}
namespace WPML\Element\API {
    class IfOriginalPost
    {
        /**
         * Gets the element details for the translations of the given post id.
         * Returns an empty array if the id is not an original post.
         *
         * element details structure:
         * ```php
         * (object) [
         *  'original' => false,            // bool True if the element is the original, false if a translation
         *  'element_id' => 123,            // int The element id
         *  'source_language_code' => 'en', // string The source language code
         *  'language_code' => 'de',        // string The language of the element
         *  'trid' => 456,                  // int The translation id that links translations to source.
         * ]
         * ```
         *
         * @param int $id The post id. Optional. If missing then returns a callable waiting for the id.
         *
         * @return \WPML\Collect\Support\Collection<mixed>|callable
         */
        public static function getTranslations($id = null)
        {
        }
        /**
         * Get the element ids for the translations of the given post id.
         * Returns an empty array if the id is not an original post.
         *
         * @param int $id The post id. Optional. If missing then returns a callable waiting for the id.
         *
         * @return \WPML\Collect\Support\Collection<mixed>|callable
         */
        public static function getTranslationIds($id = null)
        {
        }
    }
}
namespace WPML\API {
    /**
     * Class Version
     * @package WPML\API
     *
     * @method static string firstInstallation()
     *
     * It returns the version of WPML which has been used during the first installation.
     *
     * @method static callback|bool isHigherThanInstallation( ...$version ) - Curried :: string->bool
     *
     * It compares the specified version with the version which has been used during the first installation.
     *
     * @method static string current()
     *
     * It gets the current WPML version.
     */
    class Version
    {
        use \WPML\Collect\Support\Traits\Macroable;
        /**
         * @return void
         */
        public static function init()
        {
        }
    }
    class Settings
    {
        /**
         * @param string $key
         *
         * @return bool|mixed
         */
        public static function get($key)
        {
        }
        /**
         * @param mixed $default
         * @param string $key
         *
         * @return bool|mixed
         */
        public static function getOr($default, $key)
        {
        }
        /**
         * @param string $key
         * @param mixed $value
         *
         * @return bool
         */
        public static function set($key, $value)
        {
        }
        /**
         * @param string $key
         * @param mixed $value
         *
         * @return bool
         */
        public static function setAndSave($key, $value)
        {
        }
        /**
         * Updates the setting using the sub key and value.
         * Assumes that the setting found by the main key is an array or object
         *
         * @param string $key
         * @param string $subKey
         * @param mixed $value
         *
         * @return bool
         */
        public static function assoc($key, $subKey, $value)
        {
        }
        public static function pathOr($default, $path)
        {
        }
    }
}
namespace WPML\Media {
    class Option
    {
        const OPTION_KEY = '_wpml_media';
        const SETUP_FINISHED = 'starting_help';
        public static function isSetupFinished()
        {
        }
        public static function setSetupFinished($setupFinished = true)
        {
        }
        private static function get($name, $default = false)
        {
        }
        private static function set($name, $value)
        {
        }
    }
}
namespace WPML\API {
    class PostTypes
    {
        /**
         * @return array  eg. [ 'page', 'post' ]
         */
        public static function getTranslatable()
        {
        }
        /**
         * @return array  eg. [ 'page', 'post' ]
         */
        public static function getDisplayAsTranslated()
        {
        }
        /**
         * Gets post types that are translatable and excludes ones that are display as translated.
         *
         * @return array  eg. [ 'page', 'post' ]
         */
        public static function getOnlyTranslatable()
        {
        }
    }
}
namespace WPML {
    /**
     * Class UIPage
     * @package WPML
     *
     * @method static callback|bool isLanguages( ...$get ) - Curried :: array → bool
     * @method static callback|bool isTranslationManagement( ...$get ) - Curried :: array → bool
     * @method static callback|bool isTMDashboard( ...$get ) - Curried :: array → bool
     * @method static callback|bool isTMBasket( ...$get ) - Curried :: array → bool
     * @method static callback|bool isTMJobs( ...$get ) - Curried :: array → bool
     * @method static callback|bool isTMTranslators( ...$get ) - Curried :: array → bool
     * @method static callback|bool isTMATE( ...$get ) - Curried :: array → bool
     * @method static callback|bool isTroubleshooting( ...$get ) - Curried :: array → bool
     * @method static callback|bool isPage( ...$page, ...$get ) - Curried :: string → array → bool
     * @method static string getLanguages()
     * @method static string getTroubleshooting()
     * @method static string getTM()
     * @method static string getTMDashboard()
     * @method static string getTMATE()
     * @method static string getTMTranslators()
     * @method static string getTMJobs()
     * @method static string getTranslationQueue()
     */
    class UIPage
    {
        const TM_PAGE = 'tm/menu/main.php';
        use \WPML\Collect\Support\Traits\Macroable;
        public static function init()
        {
        }
        public static function isSettings(array $get = null)
        {
        }
    }
    class Timer
    {
        private $endTime;
        public function start($timeOut)
        {
        }
        public function hasTimedOut()
        {
        }
        public function hasNotTimedOut()
        {
        }
    }
}
namespace WPML\Element\API {
    /**
     * Class Translations
     * @package WPML\Element\API
     * @method static callable|int setLanguage( ...$el_id, ...$el_type, ...$trid, ...$language_code, ...$src_language_code, ...$check_duplicates )
     *
     * - Curried :: int → string → int|null → string → string → string|null → bool → bool|int|null|string
     *
     *          Wrapper function for SitePress::set_element_language_details
     *
     * - int         $el_id the element's ID (for terms we use the `term_taxonomy_id`)
     * - string      $el_type
     * - int         $trid
     * - string      $language_code
     * - null|string $src_language_code
     * - bool        $check_duplicates
     *
     * returns bool|int|null|string
     *
     * @method static callable|int setAsSource( ...$el_id, ...$el_type, ...$language_code )
     * @method static callable|int setAsTranslationOf( ...$el_id, ...$el_type, ...$translated_id, ...$language_code )
     * @method static callable|array get( ...$el_id, ...$el_type )
     * @method static callable|array getIfOriginal( ...$el_id, ...$el_type )
     * @method static callable|array getOriginal( ...$element_id, ...$element_type )
     * @method static callable|array getOriginalId( ...$element_id, ...$element_type )
     * @method static callable|bool isOriginal( ...$el_id, ...$translations )
     */
    class Translations
    {
        use \WPML\Collect\Support\Traits\Macroable;
        /**
         * @return void
         */
        public static function init()
        {
        }
    }
}
namespace {
    /**
     * @author OnTheGo Systems
     */
    interface IWPML_Action
    {
        public function add_hooks();
    }
    /**
     * @author OnTheGo Systems
     */
    interface IWPML_DIC_Action extends \IWPML_Action
    {
    }
    /**
     * @author OnTheGo Systems
     */
    interface IWPML_CLI_Action extends \IWPML_Action
    {
    }
    /**
     * @author OnTheGo Systems
     */
    interface IWPML_Action_Loader_Factory
    {
        /**
         * @return IWPML_Action|IWPML_Action[]|callable|null
         */
        public function create();
    }
    /**
     * IWPML_CLI_Action_Loader interface
     *
     * @package WPML\Core
     */
    /**
     * Interface IWPML_CLI_Action_Loader
     *
     * @author OnTheGo Systems
     */
    interface IWPML_CLI_Action_Loader extends \IWPML_Action_Loader_Factory
    {
    }
    /**
     * @author OnTheGo Systems
     */
    interface IWPML_REST_Action extends \IWPML_Action
    {
    }
    /**
     * @author OnTheGo Systems
     */
    interface IWPML_Frontend_Action extends \IWPML_Action
    {
    }
    /**
     * @author OnTheGo Systems
     */
    interface IWPML_Deferred_Action_Loader extends \IWPML_Action_Loader_Factory
    {
        /**
         * @return string
         */
        public function get_load_action();
    }
    /**
     * @author OnTheGo Systems
     */
    interface IWPML_AJAX_Action extends \IWPML_Action
    {
    }
    /**
     * @author OnTheGo Systems
     */
    interface IWPML_Frontend_Action_Loader extends \IWPML_Action_Loader_Factory
    {
    }
    /**
     * @author OnTheGo Systems
     */
    interface IWPML_REST_Action_Loader extends \IWPML_Action_Loader_Factory
    {
    }
    /**
     * @author OnTheGo Systems
     */
    interface IWPML_Backend_Action extends \IWPML_Action
    {
    }
    /**
     * @author OnTheGo Systems
     */
    interface IWPML_Backend_Action_Loader extends \IWPML_Action_Loader_Factory
    {
    }
    /**
     * @author OnTheGo Systems
     */
    interface IWPML_AJAX_Action_Loader extends \IWPML_Action_Loader_Factory
    {
    }
}
namespace WPML\Ajax {
    interface IHandler
    {
        /**
         * @param \WPML\Collect\Support\Collection<mixed> $data
         *
         * @return \WPML\FP\Either
         */
        public function run(\WPML\Collect\Support\Collection $data);
    }
}
namespace WPML\FP\Functor {
    trait Functor
    {
        /** @var mixed */
        protected $value;
        /**
         * @param  mixed  $value
         */
        public function __construct($value)
        {
        }
        /**
         * @return mixed
         */
        public function get()
        {
        }
        /**
         * @param callable $callback
         *
         * @return \WPML\FP\Either
         */
        public abstract function map(callable $callback);
    }
}
namespace WPML\FP {
    /**
     * Class Either
     * @package WPML\FP
     *
     * @method static callable|Right of( ...$value ) - Curried :: a → Right a
     *
     * @method static callable|Left left( ...$value ) - Curried :: a → Left a
     *
     * @method static callable|Right right( ...$value ) - Curried :: a → Right a
     *
     * @method static callable|Left|Right fromNullable( ...$value ) - Curried :: a → Either a
     *
     * @method static callable|Left|Right fromBool( ...$value ) - Curried :: a → Either a
     *
     * @method static Either tryCatch( ...$fn ) - Curried :: a → Either a
     *
     * @method static mixed getOrElse( ...$other )
     */
    abstract class Either
    {
        use \WPML\FP\Functor\Functor;
        use \WPML\Collect\Support\Traits\Macroable;
        /**
         * @return void
         */
        public static function init()
        {
        }
        /**
         * @return Either
         */
        public function join()
        {
        }
        /**
         * @param callable $fn
         *
         * @return mixed
         */
        public abstract function chain(callable $fn);
        /**
         * @param callable $leftFn
         * @param callable $rightFn
         *
         * @return Either|Left|Right
         */
        public abstract function bichain(callable $leftFn, callable $rightFn);
        /**
         * @param callable $fn
         *
         * @return mixed
         */
        public abstract function orElse(callable $fn);
        public abstract function bimap(callable $leftFn, callable $rightFn);
        public abstract function coalesce(callable $leftFn, callable $rightFn);
        public abstract function alt(\WPML\FP\Either $alt);
        public abstract function filter(callable $fn);
    }
    trait ConstApplicative
    {
        /**
         * @param mixed $otherContainer
         *
         * @return mixed
         */
        public function ap($otherContainer)
        {
        }
    }
}
namespace WPML\FP\Functor {
    trait Pointed
    {
        /**
         * of :: a -> M a
         *
         * Curried function that returns an instance of the derived class
         * @param mixed $value (optional)
         *
         * @return mixed|callable
         */
        public static function of($value = null)
        {
        }
    }
}
namespace WPML\FP {
    class Left extends \WPML\FP\Either
    {
        use \WPML\FP\ConstApplicative;
        use \WPML\FP\Functor\Pointed;
        /**
         * @param callable $fn
         *
         * @return Either
         */
        public function map(callable $fn)
        {
        }
        public function bimap(callable $leftFn, callable $rightFn)
        {
        }
        /**
         * @param callable $leftFn
         * @param callable $rightFn
         *
         * @return Right
         */
        public function coalesce(callable $leftFn, callable $rightFn)
        {
        }
        /**
         * @return void
         * @throws \Exception
         */
        public function get()
        {
        }
        /**
         * @param mixed $other
         *
         * @return mixed
         */
        public function getOrElse($other)
        {
        }
        /**
         * @param callable $fn
         *
         * @return Right
         */
        public function orElse(callable $fn)
        {
        }
        /**
         * @param callable $fn
         *
         * @return Either
         */
        public function chain(callable $fn)
        {
        }
        /**
         * @param callable $leftFn
         * @param callable $rightFn
         *
         * @return Either|Left|Right
         */
        public function bichain(callable $leftFn, callable $rightFn)
        {
        }
        /**
         * @param mixed $value
         *
         * @return void
         * @throws \Exception
         */
        public function getOrElseThrow($value)
        {
        }
        /**
         * @param callable $fn
         *
         * @return Either
         */
        public function filter(callable $fn)
        {
        }
        /**
         * @param callable $fn
         *
         * @return Either
         */
        public function tryCatch(callable $fn)
        {
        }
        public function alt(\WPML\FP\Either $alt)
        {
        }
    }
    trait Applicative
    {
        /**
         * @param mixed $otherContainer
         *
         * @return mixed
         */
        public function ap($otherContainer)
        {
        }
    }
    class Right extends \WPML\FP\Either
    {
        use \WPML\FP\Applicative;
        use \WPML\FP\Functor\Pointed;
        /**
         * @param callable $fn
         *
         * @return Either
         */
        public function map(callable $fn)
        {
        }
        public function bimap(callable $leftFn, callable $rightFn)
        {
        }
        /**
         * @param callable $leftFn
         * @param callable $rightFn
         *
         * @return Right
         */
        public function coalesce(callable $leftFn, callable $rightFn)
        {
        }
        /**
         * @param Either $other
         *
         * @return mixed
         */
        public function getOrElse($other)
        {
        }
        /**
         * @param callable $fn
         *
         * @return Either
         */
        public function orElse(callable $fn)
        {
        }
        /**
         * @param mixed $value
         *
         * @return mixed
         */
        public function getOrElseThrow($value)
        {
        }
        /**
         * @param callable $fn
         *
         * @return Either
         */
        public function chain(callable $fn)
        {
        }
        /**
         * @param callable $leftFn
         * @param callable $rightFn
         *
         * @return Either|Left|Right
         */
        public function bichain(callable $leftFn, callable $rightFn)
        {
        }
        /**
         * @param callable $fn
         *
         * @return Either
         */
        public function filter(callable $fn)
        {
        }
        /**
         * @param callable $fn
         *
         * @return Either
         */
        public function tryCatch(callable $fn)
        {
        }
        public function alt(\WPML\FP\Either $alt)
        {
        }
    }
    /**
     * Class Undefined
     * @package WPML\FP
     *
     * Class represents Undefined value. It let us handle correctly expected, but falsy values like null, 0 or false.
     */
    class Undefined
    {
    }
    /**
     * @method static callable|mixed multiply( ...$a, ...$b ) - Curried :: Number → Number → Number
     * @method static callable|mixed add( ...$a, ...$b ) - Curried :: Number → Number → Number
     * @method static callable|mixed product( ...$array ) - Curried :: [Number] → Number
     */
    class Math
    {
        use \WPML\Collect\Support\Traits\Macroable;
        /**
         * @return void
         */
        public static function init()
        {
        }
    }
}
namespace WPML\FP\System {
    class _Filter
    {
        /**
         * @var string
         */
        private $key;
        /**
         * @var callable
         */
        private $fn;
        /**
         * @var mixed
         */
        private $default;
        /**
         * _Filter constructor.
         *
         * @param string $key
         */
        public function __construct($key)
        {
        }
        /**
         * @param callable $fn
         *
         * @return _Filter
         */
        public function using(callable $fn)
        {
        }
        /**
         * @param mixed $default
         *
         * @return _Filter
         */
        public function defaultTo($default)
        {
        }
        /**
         * @param \WPML\Collect\Support\Collection<mixed> $collection
         *
         * @return \WPML\Collect\Support\Collection<mixed>
         */
        public function __invoke(\WPML\Collect\Support\Collection $collection)
        {
        }
    }
}
namespace WPML\FP {
    /**
     * @method static callable|array|null toArray(string ...$str) - Curried :: json -> array
     * @method static callable|Collection|null toCollection(string ...$str) Curried :: json -> null | Collection
     */
    class Json
    {
        use \WPML\Collect\Support\Traits\Macroable;
        /**
         * @return void
         */
        public static function init()
        {
        }
    }
    /**
     * @deprecated Use Fn instead
     *
     * @method static callable|mixed map( callable ...$fn, mixed ...$target ) - Curried :: (a -> b) -> f a -> f b
     * @method static callable|mixed identity( mixed ...$data ) - Curried :: a -> a
     * @method static callable|mixed always( ...$a, ...$b ) - Curried :: a -> b -> a
     * @method static callable|mixed reduce( ...$fn, ...$initial, ...$target ) - Curried :: ((a, b) → a) → a → [b] → a
     * @method static callable\mixed converge( ...$convergingFn, ...$branchingFns, ...$data ) - Curried :: callable -> [callable] -> mixed -> callable
     */
    class FP
    {
        use \WPML\Collect\Support\Traits\Macroable;
        /**
         * @return void
         */
        public static function init()
        {
        }
    }
}
namespace WPML\FP\System {
    class _Validator
    {
        /**
         * @var string
         */
        private $key;
        /**
         * @var callable
         */
        private $fn;
        /**
         * @var string
         */
        private $error;
        /**
         * _Validator constructor.
         *
         * @param string $key
         */
        public function __construct($key)
        {
        }
        /**
         * @param callable $fn
         *
         * @return _Validator
         */
        public function using(callable $fn)
        {
        }
        /**
         * @param string $error
         *
         * @return _Validator
         */
        public function error($error)
        {
        }
        /**
         * @param \WPML\Collect\Support\Collection<mixed> $collection
         *
         * @return callable|\WPML\FP\Either
         */
        public function __invoke(\WPML\Collect\Support\Collection $collection)
        {
        }
    }
}
namespace WPML\FP {
    class Promise
    {
        /** @var callable */
        private $onResolved;
        /** @var callable */
        private $onReject;
        /** @var Promise */
        private $next;
        /**
         * @param mixed $data
         *
         * @return mixed
         */
        public function resolve($data)
        {
        }
        /**
         * @param mixed $data
         *
         * @return mixed
         */
        public function reject($data)
        {
        }
        /**
         * @param callable $fn
         *
         * @return Promise
         */
        public function then(callable $fn)
        {
        }
        /**
         * @param callable $fn
         *
         * @return Promise
         */
        public function onError(callable $fn)
        {
        }
    }
    /**
     * @method static callable|bool equals( ...$a, ...$b ) - Curried :: a->b->bool
     * @method static callable|bool lt( ...$a, ...$b ) - Curried :: a->b->bool
     * @method static callable|bool lte( ...$a, ...$b ) - Curried :: a->b->bool
     * @method static callable|bool gt( ...$a, ...$b ) - Curried :: a->b->bool
     * @method static callable|bool gte( ...$a, ...$b ) - Curried :: a->b->bool
     * @method static callable|bool propEq( ...$prop, ...$value, ...$obj ) - Curried :: String → a → array → bool
     * @method static callable|array sortWith( ...$comparators, ...$array ) - Curried :: [(a, a) → int] → [a] → [a]
     */
    class Relation
    {
        use \WPML\Collect\Support\Traits\Macroable;
        /**
         * @return void
         */
        public static function init()
        {
        }
    }
    class _Invoker
    {
        /**
         * @var string
         */
        private $fnName;
        /**
         * @var mixed[]
         */
        private $args = [];
        /**
         * _Invoker constructor.
         *
         * @param string $fnName
         */
        public function __construct($fnName)
        {
        }
        /**
         * @param mixed ...$args
         *
         * @return _Invoker
         */
        public function with(...$args)
        {
        }
        /**
         * @param mixed $instance
         *
         * @return mixed
         */
        public function __invoke($instance)
        {
        }
    }
    /**
     * @method static callable always( ...$a ) Curried :: a → ( * → a )
     *
     * Returns a function that always returns the given value.
     *
     * ```php
     * $t = Fns::always( 'Tee' );
     * $t(); //=> 'Tee'
     * ```
     *
     * @method static callable converge( ...$convergingFn, ...$branchingFns ) - Curried :: ( ( x1, x2, … ) → z ) → [( ( a, b, … ) → x1 ), ( ( a, b, … ) → x2 ), …] → ( a → b → … → z )
     *
     * Accepts a converging function and a list of branching functions and returns a new function. The arity of the new function is the same as the arity of the longest branching function. When invoked, this new function is applied to some arguments, and each branching function is applied to those same arguments. The results of each branching function are passed as arguments to the converging function to produce the return value.
     *
     * ```php
     * $divide = curryN( 2, function ( $num, $dom ) { return $num / $dom; } );
     * $sum    = function ( Collection $collection ) { return $collection->sum(); };
     * $length = function ( Collection $collection ) { return $collection->count(); };
     *
     * $average = Fns::converge( $divide, [ $sum, $length ] );
     * $this->assertEquals( 4, $average( wpml_collect( [ 1, 2, 3, 4, 5, 6, 7 ] ) ) );
     * ```
     *
     * @method static callable|mixed map( ...$fn, ...$target ) - Curried :: ( a→b )→f a→f b
     *
     * Takes a function and a *functor*, applies the function to each of the functor's values, and returns a functor of the same shape.
     *
     * And array is considered a *functor*
     *
     * Dispatches to the *map* method of the second argument, if present
     *
     * @method static callable|mixed each ( ...$fn, ...$target ) - Curried :: ( a→b )→f a→f b
     * @method static callable|mixed identity( mixed ...$data ) - Curried :: a->a
     * @method static callable|mixed tap( callable  ...$fn, mixed ...$data ) - Curried :: fn->data->data
     * @method static callable|mixed reduce( ...$fn, ...$initial, ...$target ) - Curried :: ( ( a, b ) → a ) → a → [b] → a
     * @method static callable|mixed reduceRight( ...$fn, ...$initial, ...$target ) - Curried :: ( ( a, b ) → a ) → a → [b] → a
     *
     * Takes a function, an initial value and an array and returns the result.
     *
     * The function receives two values, the accumulator and the current value, and should return a result.
     *
     * The array values are passed to the function in the reverse order.
     *
     * ```php
     * $numbers = [ 1, 2, 3, 4, 5, 8, 19 ];
     *
     * $append = function( $acc, $val ) {
     *    $acc[] = $val;
     *    return $acc;
     * };
     *
     * $reducer = Fns::reduceRight( $append, [] );
     * $result = $reducer( $numbers ); // [ 19, 8, 5, 4, 3, 2, 1 ]
     *
     * // Works on collections too.
     * $result = $reducer( wpml_collect( $numbers ) ); // [ 19, 8, 5, 4, 3, 2, 1 ]
     * ```
     *
     * @method static callable|mixed filter( ...$predicate, ...$target ) - Curried :: ( a → bool ) → [a] → [a]
     * @method static callable|mixed reject( ...$predicate, ...$target ) - Curried :: ( a → bool ) → [a] → [a]
     * @method static callable|mixed value( mixed ...$data ) - Curried :: a|( *→a ) → a
     * @method static callable|object constructN( ...$argCount, ...$className ) - Curried :: int → string → object
     * @method static callable|int ascend( ...$fn, ...$a, ...$b ) - Curried :: ( a → b ) → a → a → int
     * @method static callable|int descend( ...$fn, ...$a, ...$b ) - Curried :: ( a → b ) → a → a → int
     * @method static callable useWith( ...$fn, ...$transformations ) - Curried :: ( ( x1, x2, … ) → z ) → [( a → x1 ), ( b → x2 ), …] → ( a → b → … → z )
     * @method static callable nthArg( ...$n ) - Curried :: int → *… → *
     * @method static callable|mixed either( ...$f, ...$g, ...$e ) - Curried:: ( a → b ) → ( b → c ) → Either a b → c
     * @method static callable|mixed maybe( ...$v, ...$f, ...$m ) - Curried:: b → ( a → b ) → Maybe a → b
     * @method static callable|bool isRight( ...$e ) - Curried:: e → bool
     * @method static callable|bool isLeft( ...$e ) - Curried:: e → bool
     * @method static callable|bool isJust( ...$m ) - Curried:: e → bool
     * @method static callable|bool isNothing( ...$m ) - Curried:: e → bool
     * @method static callable|mixed T( ...$_ ) - Curried :: _ → bool
     * @method static callable|mixed F( ...$_ ) - Curried :: _ → bool
     * @method static callable|Maybe safe( ...$fn ) - Curried :: ( a → b ) → ( a → Maybe b )
     * @method static callable|object make( ...$className ) - Curried :: string → object
     * @method static callable|object makeN( ...$argCount, ...$className ) - Curried :: int → string → object
     * @method static callable unary( ...$fn ) - Curried:: ( * → b ) → ( a → b )
     * @method static callable|mixed memorizeWith( ...$cacheKeyFn, ...$fn ) - Curried :: ( *… → String ) → ( *… → a ) → ( *… → a )
     * @method static callable|mixed memorize( ...$fn ) - Curried :: ( *… → a ) → ( *… → a )
     * @method static callable|mixed once( ...$fn ) - Curried :: ( *… → a ) → ( *… → a )
     * @method static callable|mixed withNamedLock( ...$name, ...$returnFn, ...$fn ) - Curried :: String → ( *… → String ) → ( *… → a ) → ( *… → a )
     *
     * Creates a new function that is *locked* so that it wont be called recursively. Multiple functions can use the same lock so they are blocked from calling each other recursively
     *
     * ```php
     *      $lockName = 'my-lock';
     *      $addOne = Fns::withNamedLock(
     *          $lockName,
     *          Fns::identity(),
     *          function ( $x ) use ( &$addOne ) { return $addOne( $x + 1 ); }
     *      );
     *
     *      $this->assertEquals( 13, $addOne( 12 ), 'Should not recurse' );
     *
     *      $addTwo = Fns::withNamedLock(
     *          $lockName,
     *          Fns::identity(),
     *          function ( $x ) use ( $addOne ) { return pipe( $addOne, $addOne) ( $x ); }
     *      );
     *
     *      $this->assertEquals( 10, $addTwo( 10 ), 'Should return 10 because $addOne is locked by the same name as $addTwo' );
     * ```
     *
     * @method static callable|mixed withoutRecursion( ...$returnFn, ...$fn ) - Curried :: ( *… → String ) → ( *… → a ) → ( *… → a )
     * @method static callable|mixed liftA2( ...$fn, ...$monadA, ...$monadB ) - Curried :: ( a → b → c ) → m a → m b → m c
     * @method static callable|mixed liftA3( ...$fn, ...$monadA, ...$monadB, ...$monadC ) - Curried :: ( a → b → c → d ) → m a → m b → m c → m d
     * @method static callable|mixed liftN( ...$n, ...$fn, ...$monad ) - Curried :: Number->( ( * ) → a ) → ( *m ) → m a
     *
     * @method static callable|mixed until( ...$predicate, ...$fns ) - Curried :: ( b → bool ) → [( a → b )] → a → b
     *
     * Executes consecutive functions until their $predicate($fn(...$args)) is true. When a result fulfils predicate then it is returned.
     *
     * ```
     *       $fns = [
     *         $add(1),
     *         $add(5),
     *         $add(10),
     *         $add(23),
     *      ];
     *
     *      $this->assertSame( 20, Fns::until( Relation::gt( Fns::__, 18 ), $fns )( 10 ) );
     * ```
     *
     */
    class Fns
    {
        use \WPML\Collect\Support\Traits\Macroable;
        const __ = '__CURRIED_PLACEHOLDER__';
        /**
         * @return void
         */
        public static function init()
        {
        }
        /**
         * @return \Closure
         */
        public static function noop()
        {
        }
        /**
         * Curried function that transforms a Maybe into an Either.
         *
         * @param mixed|null $or
         * @param Maybe|null $maybe
         *
         * @return callable|Either
         */
        public static function maybeToEither($or = null, $maybe = null)
        {
        }
    }
    /**
     * Lst class contains functions for working on ordered arrays indexed with numerical keys
     *
     * @method static callable|array append( mixed ...$newItem, array ...$data ) - Curried :: mixed->array->array
     * @method static callable|array fromPairs( array ...$array ) - Curried :: [[a, b]] → [a => b]
     * @method static callable|array toObj( array ...$array ) - Curried :: array → object
     * @method static callable|array pluck( ...$prop, ...$array ) - Curried :: string → array → array
     * @method static callable|array partition( ...$predicate, ...$target ) - Curried :: ( a → bool ) → [a] → [[a], [a]]
     * @method static callable|array sort( ...$fn, ...$target ) - Curried :: ( ( a, a ) → int ) → [a] → [a]
     * @method static callable|array unfold( ...$fn, ...$seed ) - Curried :: ( a → [b] ) → * → [b]
     * @method static callable|array zip( ...$a, ...$b ) - Curried :: [a] → [b] → [[a, b]]
     * @method static callable|array zipObj( ...$a, ...$b ) - Curried :: [a] → [b] → [a => b]
     * @method static callable|array zipWith( ...$f, ...$a, ...$b ) - Curried :: ( ( a, b ) → c ) → [a] → [b] → [c]
     * @method static callable|string join( ...$glue, ...$array ) - Curried :: string → [a] → string
     * @method static callable|array concat( ...$a, ...$b ) - Curried :: [a] → [a] → [a]
     * @method static callable|array|null find( ...$predicate, ...$array ) - Curried :: ( a → bool ) → [a] → a | null
     * @method static callable|array flattenToDepth( ...$depth, ...$array ) - Curried :: int → [[a]] → [a]
     * @method static callable|array flatten( ...$array ) - Curried :: [[a]] → [a]
     * @method static callable|bool includes( ...$val, ...$array ) - Curried :: a → [a] → bool
     * @method static callable|bool nth( ...$n, ...$array ) - Curried :: int → [a] → a | null
     * @method static callable|bool last( ...$array ) - Curried :: [a] → a | null
     * @method static callable|int length( ...$array ) - Curried :: [a] → int
     * @method static callable|array take( ...$n, ...$array ) - Curried :: int → [a] → [a]
     * @method static callable|array takeLast( ...$n, ...$array ) - Curried :: int → [a] → [a]
     * @method static callable|array slice( ...$offset, ...$limit, ...$array ) - Curried :: int → int->[a] → [a]
     * @method static callable|array drop( ...$n, ...$array ) - Curried :: int → [a] → [a]
     * @method static callable|array dropLast( ...$n, ...$array ) - Curried :: int → [a] → [a]
     * @method static callable|array makePair( ...$a, ...$b ) - Curried :: mixed → mixed → array
     * @method static callable|array make ( ...$a ) - Curried :: mixed → array
     * @method static callable|array insert( ...$index, ...$v, ...$array ) - Curried :: int → mixed → array → array
     * @method static callable|array range( ...$from, ...$to )  - Curried :: int → int → array
     * @method static callable|array xprod( ...$a, ...$b ) - Curried :: [a]->[b]->[a, b]
     *
     * Creates a new list out of the two supplied by creating each possible pair from the lists.
     *
     * ```
     * $a              = [ 1, 2, 3 ];
     * $b              = [ 'a', 'b', 'c' ];
     * $expectedResult = [
     *   [ 1, 'a' ], [ 1, 'b' ], [ 1, 'c' ],
     *   [ 2, 'a' ], [ 2, 'b' ], [ 2, 'c' ],
     *   [ 3, 'a' ], [ 3, 'b' ], [ 3, 'c' ],
     * ];
     *
     * $this->assertEquals( $expectedResult, Lst::xprod( $a, $b ) );
     * ```
     * @method static callable|array prepend( ...$val, ...$array ) - Curried:: a → [a] → [a]
     *
     * Returns a new array with the given element at the front, followed by the contents of the list.
     *
     * @method static callable|array reverse( ...$array ) - Curried:: [a] → [a]
     *
     * Returns a new array with the elements reversed.
     *
     */
    class Lst
    {
        use \WPML\Collect\Support\Traits\Macroable;
        /**
         * @return void
         */
        public static function init()
        {
        }
        /**
         * Curried function that keys the array by the given key
         *
         * keyBy :: string -> array -> array
         *
         * ```
         * $data = [
         *    [ 'x' => 'a', 'y' => 123 ],
         *    [ 'x' => 'b', 'y' => 456 ],
         * ];
         *
         * Lst::keyBy( 'x', $data );
         * [
         *    'a' => [ 'x' => 'a', 'y' => 123 ],
         *    'b' => [ 'x' => 'b', 'y' => 456 ],
         * ],
         * ```
         *
         * @param string $key
         * @param mixed[]  $array
         *
         * @return mixed[]|callable
         */
        public static function keyBy($key = null, $array = null)
        {
        }
        /**
         * This method will return the values in the original collection that are not present in the given collection:
         *
         * @param array|Collection $array1
         * @param array|Collection $array2
         *
         * @return callable|Collection|array
         */
        public static function diff($array1 = null, $array2 = null)
        {
        }
        /**
         * It returns array of $val elements repeated $times times.
         *
         * @param mixed $val
         * @param int $times
         *
         * @return callable|array[mixed]
         */
        public static function repeat($val = null, $times = null)
        {
        }
    }
}
namespace WPML\FP\System {
    class System
    {
        /**
         * @return \Closure
         */
        public static function getPostData()
        {
        }
    }
}
namespace WPML\FP {
    /**
     * @method static string tail( string ...$str ) - Curried :: string->string
     * @method static array split( ...$delimiter, ...$str ) - Curried :: string->string->string
     * @method static callable|bool includes( ...$needle, ...$str ) - Curried :: string → string → bool
     * @method static callable|string trim( ...$trim, ...$str ) - Curried :: string → string → string
     * @method static callable|string concat( ...$a, ...$b ) - Curried :: string → string → string
     * @method static callable|string sub( ...$start, ...$str ) - Curried :: int → string → string
     * @method static callable|string startsWith( ...$test, ...$str ) - Curried :: string → string → bool
     * @method static callable|string endsWith( ...$test, ...$str ) - Curried :: string → string → bool
     * @method static callable|string pos( ...$test, ...$str ) - Curried :: string → string → int
     * @method static callable|string len( ...$str ) - Curried :: string → int
     * @method static callable|string replace( ...$find, ...$replace, ...$str ) - Curried :: string → string → string → string
     * @method static callable|string pregReplace( ...$pattern, ...$replace, ...$str ) - Curried :: string → string → string → string
     * @method static callable|string match( ...$pattern, ...$str ) - Curried :: string → string → array
     * @method static callable|string matchAll( ...$pattern, ...$str ) - Curried :: string → string → array
     * @method static callable|string wrap( ...$before, ...$after, ...$str ) - Curried :: string → string → string
     * @method static callable|string toUpper( string ...$str ) - Curried :: string → string
     * @method static callable|string toLower( string ...$str ) - Curried :: string → string
     *
     * Wraps a string inside 2 other strings
     *
     * ```
     * $wrapsInDiv = Str::wrap( '<div>', '</div>' );
     * $wrapsInDiv( 'To be wrapped' ); // '<div>To be wrapped</div>'
     * ```
     *
     */
    class Str
    {
        use \WPML\Collect\Support\Traits\Macroable;
        /**
         * @return void
         */
        public static function init()
        {
        }
    }
    class Wrapper
    {
        use \WPML\FP\Functor\Functor;
        use \WPML\FP\Functor\Pointed;
        /**
         * @param callable $fn
         *
         * @return Wrapper
         */
        public function map(callable $fn)
        {
        }
        /**
         * @param callable $fn
         *
         * @return mixed|null
         */
        public function filter($fn = null)
        {
        }
        /**
         * @return mixed
         */
        public function join()
        {
        }
        /**
         * @param mixed $value
         *
         * @return Wrapper
         */
        public function ap($value)
        {
        }
        /**
         * @return mixed
         */
        public function get()
        {
        }
    }
    /**
     * Class Maybe
     * @package WPML\FP
     * @method static callable|Just|Nothing fromNullable( ...$value ) - Curried :: a → Nothing | Just a
     *
     * if $value is null or false it returns a Nothing otherwise returns a Just containing the value
     *
     * @method static callable safe( ...$fn ) - Curried :: ( a → b ) → ( a → Maybe b )
     *
     * returns a function that when called will run the passed in function and put the result into a Maybe
     *
     * @method static callable safeAfter( ...$predicate, ...$fn ) - Curried :: ( b → bool ) → ( a → b ) → ( a → Maybe b )
     *
     * returns a function that when called will run the passed in function and pass the result of the function
     * to the predicate. If the predicate returns true the result will be a Just containing the result of the function.
     * Otherwise it returns a Nothing if the predicate returns false.
     *
     * @method static callable safeBefore( ...$predicate, ...$fn ) - Curried :: ( a → bool ) → ( a → b ) → ( a → Maybe b )
     *
     * returns a function that when called will pass the given value to the predicate.
     * If the predicate returns true the value will be lifted into a Just instance and
     * the passed in function will then be mapped.
     * Otherwise it returns a Nothing if the predicate returns false.
     *
     * @method static callable|Just just( ...$value ) - Curried :: a → Just a
     *
     * returns a Just containing the value.
     *
     * @method static callable|Just of( ...$value ) - Curried :: a → Just a
     *
     * returns a Just containing the value.
     *
     */
    class Maybe
    {
        use \WPML\Collect\Support\Traits\Macroable;
        /**
         * @return void
         */
        public static function init()
        {
        }
        /**
         * @return Nothing
         */
        public static function nothing()
        {
        }
        /**
         * @return bool
         */
        public function isNothing()
        {
        }
        /**
         * @return bool
         */
        public function isJust()
        {
        }
    }
    class Just extends \WPML\FP\Maybe
    {
        use \WPML\FP\Functor\Functor;
        use \WPML\FP\Functor\Pointed;
        use \WPML\FP\Applicative;
        /**
         * @param callable $fn
         *
         * @return Just|Nothing
         */
        public function map(callable $fn)
        {
        }
        /**
         * @param mixed $other
         *
         * @return mixed
         */
        public function getOrElse($other)
        {
        }
        /**
         * @param callable $fn
         *
         * @return Just|Nothing
         */
        public function filter($fn = null)
        {
        }
        /**
         * @param callable $fn
         *
         * @return Just|Nothing
         */
        public function reject($fn = null)
        {
        }
        /**
         * @param callable $fn
         *
         * @return mixed
         */
        public function chain(callable $fn)
        {
        }
        /**
         * @return bool
         */
        public function isJust()
        {
        }
    }
    class Nothing extends \WPML\FP\Maybe
    {
        use \WPML\FP\ConstApplicative;
        /**
         * @param callable $fn
         *
         * @return Nothing
         */
        public function map(callable $fn)
        {
        }
        /**
         * @return void
         * @throws \Exception
         */
        public function get()
        {
        }
        /**
         * @param mixed|callable $other
         *
         * @return mixed
         */
        public function getOrElse($other)
        {
        }
        /**
         * @param callable $fn
         *
         * @return Nothing
         */
        public function filter(callable $fn)
        {
        }
        /**
         * @param callable $fn
         *
         * @return Nothing
         */
        public function reject(callable $fn)
        {
        }
        /**
         * @param callable $fn
         *
         * @return Nothing
         */
        public function chain(callable $fn)
        {
        }
        /**
         * @return bool
         */
        public function isNothing()
        {
        }
    }
    /**
     * @method static callable|bool not( mixed ...$v ) - Curried :: mixed->bool
     * @method static callable|bool isNotNull( mixed ...$v ) - Curried :: mixed->bool
     * @method static callable|mixed ifElse( ...$predicate, ...$first, ...$second, ...$data ) - Curried :: ( a->bool )->callable->callable->callable
     * @method static callable when( ...$predicate, ...$fn ) - Curried :: ( a->bool )->callable->callable
     * @method static callable unless( ...$predicate, ...$fn ) - Curried :: ( a->bool )->callable->callable
     * @method static callable cond( ...$conditions, ...$fn ) - Curried :: [( a->bool ), callable]->callable
     * @method static callable both( ...$a, ...$b, ...$data ) - Curried :: ( a → bool ) → ( a → bool ) → a → bool
     * @method static callable allPass( array $predicates ) - Curried :: [( *… → bool )] → ( *… → bool )
     * @method static callable anyPass( array $predicates ) - Curried :: [( *… → bool )] → ( *… → bool )
     * @method static callable complement( ...$fn ) - Curried :: ( *… → * ) → ( *… → bool )
     * @method static callable|mixed defaultTo( ...$a, ...$b ) - Curried :: a → b → a | b
     * @method static callable|bool either( ...$a, ...$b ) - Curried :: ( *… → bool ) → ( *… → bool ) → ( *… → bool )
     * @method static callable|mixed until ( ...$predicate, ...$transform, ...$data ) - Curried :: ( a → bool ) → ( a → a ) → a → a
     * @method static callable|bool propSatisfies( ...$predicate, ...$prop, ...$data ) - Curried :: ( a → bool ) → String → [String => a] → bool
     * @method static callable|bool isArray ( ...$a ) - Curried :: a → bool
     * @method static callable|bool isEmpty( ...$a ) - Curried:: a → bool
     * @method static callable|mixed firstSatisfying( ...$predicate, ...$functions, ...$data ) - Curried:: callable->callable[]->mixed->mixed
     * @method static callable|bool isTruthy( ...$data ) - Curried:: mixed->bool
     */
    class Logic
    {
        use \WPML\Collect\Support\Traits\Macroable;
        /**
         * @return void
         */
        public static function init()
        {
        }
    }
}
namespace WPML\FP\Functor {
    class IdentityFunctor
    {
        use \WPML\FP\Functor\Functor;
        use \WPML\FP\Functor\Pointed;
        /**
         * @param callable $callback
         *
         * @return IdentityFunctor
         */
        public function map($callback)
        {
        }
    }
    class ConstFunctor
    {
        use \WPML\FP\Functor\Functor;
        use \WPML\FP\Functor\Pointed;
        /**
         * @param callable $callback
         *
         * @return ConstFunctor
         */
        public function map($callback)
        {
        }
    }
}
namespace WPML\FP {
    /**
     * @method static callable|mixed prop( ...$key, ...$obj ) - Curried :: string->Collection|array|object->mixed|null
     * @method static callable|mixed propOr( ...$default, ...$key, ...$obj ) - Curried :: mixed->string->Collection|array|object->mixed|null
     * @method static callable|array props( ...$keys, ...$obj ) - Curried :: [keys] → Collection|array|object → [v]
     * @method static callable|array|\stdClass addProp( ...$key, ...$transformation, ...$obj ) - Curried :: string->callable->object|array->object->array
     * @method static callable|array|\stdClass removeProp( ...$key, ...$obj ) - Curried :: string->object|array->object->array
     * @method static callable|array|\stdClass renameProp( ...$key, ...$newKey, ...$obj ) - Curried :: string->string->object|array->object->array
     * @method static callable|mixed path( ...$path, ...$obj ) - Curried :: array->Collection|array|object->mixed|null
     * @method static callable|mixed pathOr( ...$default, ...$path, ...$obj ) - Curried :: mixed → array → Collection|array|object → mixed
     * @method static callable assoc( ...$key, ...$value, ...$item ) - Curried :: string->mixed->Collection|array|object->mixed|null
     * @method static callable assocPath( ...$path, ...$value, ...$item ) - Curried :: array->mixed->Collection|array|object->mixed|null
     * @method static callable lens( ...$getter, ...$setter ) - Curried :: callable->callable->callable
     * @method static callable lensProp( ...$prop ) - Curried :: string->callable
     * @method static callable lensPath( ...$path ) - Curried :: array->callable
     * @method static callable view( ...$lens, ...$obj ) - Curried :: callable->Collection|array|object->mixed
     * @method static callable set( ...$lens, ...$value, ...$obj ) - Curried :: callable->mixed->Collection|array|object->mixed
     * @method static callable over( ...$lens, ...$transformation, ...$obj ) - Curried :: callable->callable->Collection|array|object->mixed
     * @method static callable pick( ...$props, ...$obj ) - Curried :: array->Collection|array->Collection|array
     * @method static callable pickAll( ...$props, ...$obj ) - Curried :: array->Collection|array->Collection|array
     * @method static callable pickBy( ...$predicate, ...$obj ) - Curried :: ( ( v, k ) → bool ) → Collection|array->Collection|array
     * @method static callable project( ...$props, ...$target ) - Curried :: array->Collection|array->Collection|array
     * @method static callable where( array $condition ) - Curried :: [string → ( * → bool )] → bool
     * @method static callable|bool has( ...$prop, ...$item ) - Curried :: string → a → bool
     * @method static callable|mixed evolve( ...$transformations, ...$item ) - Curried :: array → array → array
     *
     * @method static callable|array objOf( ...$key, ...$value ) - Curried :: string->mixed->array
     *
     * Creates an object containing a single key:value pair.
     *
     * @method static callable|array keys( ...$obj ) - Curried :: object|array->array
     *
     * Returns
     *  - keys if argument is an array
     *  - public properties' names if argument is an object
     *  - keys if argument is Collection
     *
     * ```
     * $this->assertEquals( [ 0, 1, 2 ], Obj::keys( [ 'a', 'b', 'c' ] ) );
     * $this->assertEquals( [ 'a', 'b', 'c' ], Obj::keys( [ 'a' => 1, 'b' => 2, 'c' => 3 ] ) );
     *
     * $this->assertEquals( [ 0, 1, 2 ], Obj::keys( \wpml_collect( [ 'a', 'b', 'c' ] ) ) );
     * $this->assertEquals( [ 'a', 'b', 'c' ], Obj::keys( \wpml_collect( [ 'a' => 1, 'b' => 2, 'c' => 3 ] ) ) );
     *
     * $this->assertEquals( [ 'a', 'b', 'c' ], Obj::keys( (object) [ 'a' => 1, 'b' => 2, 'c' => 3 ] ) );
     * ```
     *
     * @method static callable|array values( ...$obj ) - Curried :: object|array->array
     *
     * Returns
     *  - values if argument is an array
     *  - public properties' values if argument is an object
     *  - values if argument is Collection
     *
     * ```
     * $this->assertEquals( [ 'a', 'b', 'c' ], Obj::values( [ 'a', 'b', 'c' ] ) );
     * $this->assertEquals( [ 1, 2, 3 ], Obj::values( [ 'a' => 1, 'b' => 2, 'c' => 3 ] ) );
     *
     * $this->assertEquals( [ 'a', 'b', 'c' ], Obj::values( \wpml_collect( [ 'a', 'b', 'c' ] ) ) );
     * $this->assertEquals( [ 1, 2, 3 ], Obj::values( \wpml_collect( [ 'a' => 1, 'b' => 2, 'c' => 3 ] ) ) );
     *
     * $this->assertEquals( [ 1, 2, 3 ], Obj::values( (object) [ 'a' => 1, 'b' => 2, 'c' => 3 ] ) );
     * ```
     *
     * @method static callable|array replaceRecursive( array ...$newValue, ...$target ) - Curried :: array->array->array
     *
     * @method static callable|array toArray( Collection|Object ...$item ) - Curried :: Collection|Object->array
     */
    class Obj
    {
        use \WPML\Collect\Support\Traits\Macroable;
        /**
         * @return void
         */
        public static function init()
        {
        }
        /**
         * @param object|Collection $item
         * @param object|Collection $reference
         *
         * @return object|Collection
         */
        private static function matchType($item, $reference)
        {
        }
        /**
         * Curried :: mixed → array|object|Collection → array|object|Collection
         * function to remove an item by key from an array.
         *
         * @param string|int                   $key
         * @param array|object|Collection|null $item
         *
         * @return callable|array|object|Collection
         */
        static function without($key = null, $item = null)
        {
        }
    }
}
namespace WPML\LIB\WP {
    /**
     * @method static callable|bool hasBlock( ...$string ) - Curried :: string → bool
     * @method static callable|bool doesNotHaveBlock( ...$string ) - Curried :: string → bool
     * @method static callable|bool stripBlockData( ...$string ) - Curried :: string → string
     */
    class Gutenberg
    {
        use \WPML\FP\Curryable;
        const GUTENBERG_OPENING_START = '<!-- wp:';
        /**
         * @return void
         */
        public static function init()
        {
        }
    }
    /**
     * Class Post
     * @package WPML\LIB\WP
     * @method static callable|Either getTerms( ...$postId, ...$taxonomy )  - Curried:: int → string → Either false|WP_Error [WP_Term]
     * @method static callable|mixed getMetaSingle( ...$postId, ...$key ) - Curried :: int → string → mixed
     * @method static callable|int|bool updateMeta( ...$postId, ...$key, ...$value ) - Curried :: int → string → mixed → int|bool
     * @method static callable|string|false getType( ...$postId ) - Curried :: int → string|bool
     * @method static callable|\WP_Post|null get( ...$postId ) - Curried :: int → \WP_Post|null
     * @method static callable|string|false getStatus( ...$postId ) - Curried :: int → string|bool
     * @method static callable|int update(...$data) - Curried :: array -> int
     * @method static callable|int setStatus(...$id, ...$status) - Curried :: int -> string -> int
     */
    class Post
    {
        use \WPML\Collect\Support\Traits\Macroable;
        /**
         * @return void
         */
        public static function init()
        {
        }
    }
    class Roles
    {
        public static function hasCap($cap = null, $role = null)
        {
        }
    }
    /**
     * Class PostType
     * @package WPML\LIB\WP
     * @method static callable|int getPublishedCount( ...$postType ) - Curried :: string → int
     * @method static callable|Just|Nothing getObject( ...$postType ) - Curried :: string → Maybe( WP_Post_Type )|Nothing
     * @method static callable|Just|Nothing getPluralName( ...$postType ) - Curried :: string → Maybe(string) |Nothing
     * @method static callable|Just|Nothing getSingularName( ...$postType ) - Curried :: string → Maybe(string) |Nothing
     */
    class PostType
    {
        use \WPML\Collect\Support\Traits\Macroable;
        /**
         * @return void
         */
        public static function init()
        {
        }
    }
    /**
     * @method static callable|mixed get( ...$name ) - Curried :: string → mixed
     * @method static callable|mixed getOr( ...$name, ...$default ) - Curried :: string → mixed → mixed
     * @method static callable|bool update( ...$name, ...$value ) - Curried :: string → mixed → bool
     * @method static callable|bool updateWithoutAutoLoad( ...$name, ...$value ) - Curried :: string → mixed → bool
     * @method static callable|bool delete( ...$name ) - Curried :: string → bool
     */
    class Option
    {
        use \WPML\Collect\Support\Traits\Macroable;
        /**
         * @return void
         */
        public static function init()
        {
        }
    }
    class User
    {
        /**
         * @return int
         */
        public static function getCurrentId()
        {
        }
        /**
         * @return \WP_User|null
         */
        public static function getCurrent()
        {
        }
        /**
         * Curried function to update the user meta.
         *
         * @param int    $userId
         * @param string $metaKey
         * @param mixed  $metaValue
         *
         * @return callable|int|bool
         */
        public static function updateMeta($userId = null, $metaKey = null, $metaValue = null)
        {
        }
        /**
         * Curried function to get the user meta
         *
         * @param int    $userId
         * @param string $metaKey
         *
         * @return callable|mixed
         */
        public static function getMetaSingle($userId = null, $metaKey = null)
        {
        }
        /**
         * Curried function to get the user meta
         *
         * @param int    $userId
         * @param string $metaKey
         *
         * @return callable|bool
         */
        public static function deleteMeta($userId = null, $metaKey = null)
        {
        }
        /**
         * @param int|null $userId
         *
         * @return callable|\WP_User
         */
        public static function get($userId = null)
        {
        }
        /**
         * @param array|null $data
         *
         * @return callable|int|\WP_Error
         */
        public static function insert($data = null)
        {
        }
        /**
         * @param int|null $userId
         *
         * @return callable|int
         */
        public static function notifyNew($userId = null)
        {
        }
        /**
         * Add the avatar to a user.
         *
         * @param object|\WP_User $user
         *
         * @return callable|object
         */
        public static function withAvatar($user = null)
        {
        }
        /**
         * Add the edit link to a user.
         *
         * @param object|\WP_User $user
         *
         * @return callable|object
         */
        public static function withEditLink($user = null)
        {
        }
    }
    /**
     * Class Cache
     * @package WPML\LIB\WP
     * @method static callable|mixed memorize( ...$group, ...$fn ) :: string → callable → mixed
     * @method static callable|mixed memorizeWithCheck( ...$group, ...$checkingFn, ...$fn ) :: string → callable → callable → mixed
     * @method static callable|bool set( ...$group, ...$key, ...$value ) :: string → string → mixed → bool
     * @method static callable|Maybe get( ...$group, ...$key ) :: string → string → Nothing | Just( mixed )
     */
    class Cache
    {
        use \WPML\Collect\Support\Traits\Macroable;
        /**
         * @return void
         */
        public static function init()
        {
        }
        /**
         * @param string $group
         * @param string $key
         *
         * @return \WPML\FP\Just|\WPML\FP\Nothing
         */
        public static function getInternal($group, $key)
        {
        }
        /**
         * @param string $group
         * @param string $key
         * @param mixed  $value
         *
         * @return bool|true
         */
        public static function setInternal($group, $key, $value)
        {
        }
    }
    /**
     * @method static callable|Either post( ...$url, ...$args ) - Curried :: string → array → Left( WP_Error ) | Right(string)
     */
    class Http
    {
        use \WPML\Collect\Support\Traits\Macroable;
        /**
         * @return void
         */
        public static function init()
        {
        }
    }
}
namespace WPML\LIB\WP\App {
    class Resources
    {
        /**
         * Enqueue a JavaScript application file from the dist directory.
         *
         * @param string        $app
         * @param string        $pluginBaseUrl
         * @param string        $pluginBasePath
         * @param string        $version
         * @param null|string   $domain
         * @param null|string[] $localize
         *
         * @return void
         */
        public static function enqueue($app, $pluginBaseUrl, $pluginBasePath, $version, $domain = null, $localize = null)
        {
        }
    }
}
namespace WPML\LIB\WP {
    class WordPress
    {
        /**
         * Compare the WordPress version.
         * @param string $operator
         * @param string $version
         *
         * @return bool
         */
        public static function versionCompare($operator, $version)
        {
        }
        /**
         * @param mixed $var
         *
         * @return \WPML\FP\Either|callable
         */
        public static function handleError($var = null)
        {
        }
    }
    class Hooks
    {
        /**
         * @param string|string[] $action
         * @param int             $priority
         * @param int             $accepted_args
         *
         * @return \WPML\FP\Promise
         */
        public static function onAction($action, $priority = 10, $accepted_args = 1)
        {
        }
        /**
         * @param string|string[] $filter
         * @param int             $priority
         * @param int             $accepted_args
         *
         * @return \WPML\FP\Promise
         */
        public static function onFilter($filter, $priority = 10, $accepted_args = 1)
        {
        }
        /**
         * @param callable        $fn
         * @param string|string[] $actionOrFilter
         * @param int             $priority
         * @param int             $accepted_args
         *
         * @return \WPML\FP\Promise
         */
        public static function onHook(callable $fn, $actionOrFilter, $priority = 10, $accepted_args = 1)
        {
        }
        public static function callWithFilter($fn, $name, $filterFn, $priority = 10, $acceptedArgs = 1)
        {
        }
        public static function getArgs(array $argsLabels)
        {
        }
    }
    /**
     * @method static callable|Either verify(string ...$action, Collection ...$data) - Curried :: string -> Collection -> Left('Nonce error') | Right(Collection)
     * @method static callable|Either verifyEndPoint(Collection ...$data) - Curried :: Collection -> Left('Nonce error') | Right(Collection)
     * @method static callable|string create(string ...$action ) - Curried :: string -> string
     */
    class Nonce
    {
        use \WPML\Collect\Support\Traits\Macroable;
        /**
         * @return void
         */
        public static function init()
        {
        }
    }
}